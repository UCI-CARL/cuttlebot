#!/usr/bin/env python3
# This file is automatically generated!
# Toy Name:           Sphero RVR
# Prefix:             RV
# Command Count:      93
# Timestamp:          08/20/2020 @ 02:17:14.029949 (UTC)

import asyncio
import logging.config
from sphero_sdk.asyncio.config import logging_config
from sphero_sdk.common.log_level import LogLevel
from sphero_sdk.common.commands import api_and_shell
from sphero_sdk.common.commands import system_info
from sphero_sdk.common.commands import power
from sphero_sdk.common.commands import drive
from sphero_sdk.common.commands import sensor
from sphero_sdk.common.commands import connection
from sphero_sdk.common.commands import io
from sphero_sdk import LedControlAsync
from sphero_sdk import DriveControlAsync
from sphero_sdk import InfraredControlAsync
from sphero_sdk import SensorControlAsync
from sphero_sdk import RvrFwCheckAsync


class SpheroRvrAsync(RvrFwCheckAsync): 
    def __init__(self, dal, log_level=LogLevel.Silent): 
        logging.config.dictConfig(logging_config.get_dict(log_level))
        RvrFwCheckAsync.__init__(self)
        self._dal = dal
        self._led_control = LedControlAsync(self)
        self._drive_control = DriveControlAsync(self)
        self._infrared_control = InfraredControlAsync(self)
        self._sensor_control = SensorControlAsync(self)
        asyncio.get_event_loop().run_until_complete( 
            self._check_rvr_fw() 
        )

    @property 
    def led_control(self): 
        return self._led_control

    @property 
    def drive_control(self): 
        return self._drive_control

    @property 
    def infrared_control(self): 
        return self._infrared_control

    @property 
    def sensor_control(self): 
        return self._sensor_control

    @property 
    def request_error_responses_only(self): 
        return self._dal.request_error_responses_only 

    @request_error_responses_only.setter 
    def request_error_responses_only(self, is_enabled): 
        self._dal.request_error_responses_only = is_enabled 

    async def close(self): 
        if len(self._sensor_control.enabled_sensors) > 0: 
            await self._sensor_control.clear()
        
        await asyncio.sleep(.2)

        await self._dal.close()

    async def echo(self, data, target, timeout=None): 
        """Echo back the payload data (zero data is equivalent to a ping).

        Args:
            data (list(uint8_t)): Payload data to be echoed as an integer between 0 and 255.
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: data (list(uint8_t))
        """
        command_dict = api_and_shell.echo(data, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def generate_api_error(self, error, target, timeout=None): 
        """Generates the given API error for testing purposes

        Args:
            error (uint8_t): The API error you would like to generate in the response
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = api_and_shell.generate_api_error(error, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_main_application_version(self, target, timeout=None): 
        """Gets the version of the main application.

        Args:
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: major (uint16_t), minor (uint16_t), revision (uint16_t)
        """
        command_dict = system_info.get_main_application_version(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bootloader_version(self, target, timeout=None): 
        """Gets the version of the bootloader.

        Args:
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: major (uint16_t), minor (uint16_t), revision (uint16_t)
        """
        command_dict = system_info.get_bootloader_version(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_board_revision(self, timeout=None): 
        """Gets the board revision number.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: revision (uint8_t)
        """
        command_dict = system_info.get_board_revision(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_mac_address(self, timeout=None): 
        """Gets the robot's MAC address.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: mac_address (str)
        """
        command_dict = system_info.get_mac_address(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_stats_id(self, timeout=None): 
        """Gets the id number assigned by the company for activation tracking.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: stats_id (uint16_t)
        """
        command_dict = system_info.get_stats_id(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_processor_name(self, target, timeout=None): 
        """Returns the processor name string (as specified to the System Info module). If no name is specified, returns an empty string or no string.

        Args:
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.

        Returns:
            dict: name (str)
        """
        command_dict = system_info.get_processor_name(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_sku(self, timeout=None): 
        """Returns the SKU of the bot.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: sku (str)
        """
        command_dict = system_info.get_sku(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_core_up_time_in_milliseconds(self, timeout=None): 
        """Returns the time (in milliseconds) that has passed since the latest power cycle started.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: up_time (uint64_t)
        """
        command_dict = system_info.get_core_up_time_in_milliseconds(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def sleep(self, timeout=None): 
        """Put robot into a soft sleep state. Driving, LEDS, and sensors are disabled.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.sleep(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def wake(self, timeout=None): 
        """Wake up the system from soft sleep. Nothing to do if awake.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = power.wake(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_percentage(self, timeout=None): 
        """Get usable battery percentage remaining.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: percentage (uint8_t)
        """
        command_dict = power.get_battery_percentage(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_voltage_state(self, timeout=None): 
        """Returns the current battery state

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: state (uint8_t)
        """
        command_dict = power.get_battery_voltage_state(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_will_sleep_notify(self, handler=None, timeout=None): 
        """Notification triggered 10 seconds before soft/deep sleep.

        Args:
            handler (function): called asynchronously, takes form handler().
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = power.on_will_sleep_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def on_did_sleep_notify(self, handler=None, timeout=None): 
        """Notification triggered when robot has entered soft/deep sleep.

        Args:
            handler (function): called asynchronously, takes form handler().
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = power.on_did_sleep_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def enable_battery_voltage_state_change_notify(self, is_enabled, timeout=None): 
        """Enables or disables notifications for changes to battery voltage state.

        Args:
            is_enabled (bool): Indicates whether battery voltage state notifications should be enabled. True is enabled. False is disabled.
            timeout (float): maximum time to await a response.
        """
        command_dict = power.enable_battery_voltage_state_change_notify(is_enabled, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_battery_voltage_state_change_notify(self, handler=None, timeout=None): 
        """Notification for battery voltage state change.

        Args:
            handler (function): called asynchronously, takes form handler(state).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = power.on_battery_voltage_state_change_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_battery_voltage_in_volts(self, reading_type, timeout=None): 
        """Returns the most recent battery voltage reading in volts. This results in a 'Command Failed' API error if the platform does not support calibration. Note that this command does not get a new voltage reading; it returns the most recently read value, which is updated once per second on most robots. To force the battery system to read a new value, use the 'Force Battery Refresh' command.

        Args:
            reading_type (uint8_t): Integer value indicating the type of reading you are seeking.
            timeout (float): maximum time to await a response.

        Returns:
            dict: voltage (float)
        """
        command_dict = power.get_battery_voltage_in_volts(reading_type, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_voltage_state_thresholds(self, timeout=None): 
        """Returns the battery voltage state thresholds and hysteresis value. The hysteresis value is added to the thresholds for rising voltages -- e.g., the voltage must be less than the low threshold to change the state to 'low battery' but it must be greater than (low threshold + hysteresis) to go back to the 'ok battery' state.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: critical_threshold (float), low_threshold (float), hysteresis (float)
        """
        command_dict = power.get_battery_voltage_state_thresholds(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_current_sense_amplifier_current(self, amplifier_id, timeout=None): 
        """Get the current draw, in AMPS, from a current sense amplifier

        Args:
            amplifier_id (uint8_t): Motor amplifier id
            timeout (float): maximum time to await a response.

        Returns:
            dict: amplifier_current (float)
        """
        command_dict = power.get_current_sense_amplifier_current(amplifier_id, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def raw_motors(self, left_mode, left_duty_cycle, right_mode, right_duty_cycle, timeout=None): 
        """Run left and right motors at a normalized duty cycle between 0 and 255. Set driving mode using flags.

        Args:
            left_mode (uint8_t): Drive mode: 0x0-off, 0x1-forward, 0x2-reverse
            left_duty_cycle (uint8_t): Duty cycle normalized to 0-255
            right_mode (uint8_t): Drive mode: 0x0-off, 0x1-forward, 0x2-reverse
            right_duty_cycle (uint8_t): Duty cycle normalized to 0-255
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.raw_motors(left_mode, left_duty_cycle, right_mode, right_duty_cycle, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def reset_yaw(self, timeout=None): 
        """Sets current yaw angle to zero. (ie current direction is now considered 'forward'.)

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.reset_yaw(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_with_heading(self, speed, heading, flags, timeout=None): 
        """Drive towards a heading at a particular speed. Flags can be set to modify driving mode.

        Args:
            speed (uint8_t): 0 to 255 value
            heading (uint16_t): 0 to 359 degrees (0 degrees is forward, 90 degrees is to the right, 180 degrees is back, and 270 is to the left)
            flags (uint8_t): Relevant flags: Drive Reverse, Boost, Fast Turn Mode
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_with_heading(speed, heading, flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_default_control_system_for_type(self, control_system_type, controller_id, timeout=None): 
        """Set the default control system for a given control system type

        Args:
            control_system_type (uint8_t): Control system type
            controller_id (uint8_t): Controller ID
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.set_default_control_system_for_type(control_system_type, controller_id, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_custom_control_system_timeout(self, command_timeout, timeout=None): 
        """set_custom_control_system_timeout

        Args:
            command_timeout (uint16_t): None
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.set_custom_control_system_timeout(command_timeout, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_motor_stall_notify(self, is_enabled, timeout=None): 
        """Enables motor stall notifications.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.enable_motor_stall_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_motor_stall_notify(self, handler=None, timeout=None): 
        """Motor stall protection change notification.

        Args:
            handler (function): called asynchronously, takes form handler(motor_index, is_triggered).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = drive.on_motor_stall_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def enable_motor_fault_notify(self, is_enabled, timeout=None): 
        """Enables notification for when there is a motor fault.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.enable_motor_fault_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_motor_fault_notify(self, handler=None, timeout=None): 
        """Notification that a motor fault has occurred.

        Args:
            handler (function): called asynchronously, takes form handler(is_fault).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = drive.on_motor_fault_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_motor_fault_state(self, timeout=None): 
        """Get the motor fault state.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: is_fault (bool)
        """
        command_dict = drive.get_motor_fault_state(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_tank_si_units(self, left_velocity, right_velocity, timeout=None): 
        """Tank drive with left and right linear velocity targets in m/s

        Args:
            left_velocity (float): left wheel velocity in m/s
            right_velocity (float): right wheel velocity in m/s
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_tank_si_units(left_velocity, right_velocity, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_tank_normalized(self, left_velocity, right_velocity, timeout=None): 
        """Tank drive with left and right linear velocity targets normalized to +/-127

        Args:
            left_velocity (int8_t): left wheel velocity
            right_velocity (int8_t): right wheel velocity
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_tank_normalized(left_velocity, right_velocity, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_rc_si_units(self, yaw_angular_velocity, linear_velocity, flags, timeout=None): 
        """Drive RC-style with linear and angular velocity targets in SI Units

        Args:
            yaw_angular_velocity (float): Yaw angular velocity target in degrees/s, following the right hand rule: positive is CCW viewed from above.
            linear_velocity (float): Linear velocity target in m/s
            flags (uint8_t): Relevant flags: Use Linear Velocity Slew Limiting
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_rc_si_units(yaw_angular_velocity, linear_velocity, flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_rc_normalized(self, yaw_angular_velocity, linear_velocity, flags, timeout=None): 
        """Drive RC-style with linear and angular velocity targets normalized between +/-127

        Args:
            yaw_angular_velocity (int8_t): Yaw angular velocity target normalized to +/-127. Follows the right-hand rule: CW negative, CCW positive
            linear_velocity (int8_t): Linear velocity target normalized to +/-127.  Positive is forward, negative is reverse.
            flags (uint8_t): Relevant flags: Use Linear Velocity Slew Limiting
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_rc_normalized(yaw_angular_velocity, linear_velocity, flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_with_yaw_si(self, yaw_angle, linear_velocity, timeout=None): 
        """Drive following a target yaw angle and a target linear velocity using SI units

        Args:
            yaw_angle (float): Yaw angle target. Follows the right-hand rule: CW negative, CCW positive, with 0 straight ahead on boot or resetting yaw
            linear_velocity (float): Linear velocity target in m/s. Positive is forward, negative is backward.
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_with_yaw_si(yaw_angle, linear_velocity, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_with_yaw_normalized(self, yaw_angle, linear_velocity, timeout=None): 
        """Drive following a target yaw angle and a target linear velocity normalized to +/-127

        Args:
            yaw_angle (int16_t): Yaw angle target. Follows the right-hand rule: CW negative, CCW positive, with 0 straight ahead on boot or resetting yaw.  Values wrap internally
            linear_velocity (int8_t): Linear velocity target normalized to +/-127 for the achievable range of a particular robot model.  127 is full speed forward, -127 is full speed reverse.
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_with_yaw_normalized(yaw_angle, linear_velocity, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_to_position_si(self, yaw_angle, x, y, linear_speed, flags, timeout=None): 
        """Drive to an (x,y) coordinate and turn to the specified target yaw angle using SI units

        Args:
            yaw_angle (float): Target yaw angle after arriving at target position.  Follows the right-hand rule: CW negative, CCW positive, with 0 straight ahead on boot or resetting yaw.  Values wrap internally
            x (float): Target Position X coordinate in the locator coordinate system, in meters.  The positive X axis is to the right on boot or locator reset (along yaw angle -90 degrees)
            y (float): Target Position Y coordinate in the locator coordinate system, in meters.  The positive Y axis is forward on boot or locator reset
            linear_speed (float): Maximum allowable linear speed in transit to the target position, in m/s.  Negative values are invalid.  If the distance to target is too short for the robot to accelerate to this velocity, the resulting velocity trajectory will be triangular rather than trapezoidal.
            flags (uint8_t): Option flags
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_to_position_si(yaw_angle, x, y, linear_speed, flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_to_position_normalized(self, yaw_angle, x, y, linear_speed, flags, timeout=None): 
        """Drive to an (x,y) coordinate at a normalized speed and turn to the specified target yaw angle

        Args:
            yaw_angle (int16_t): Target yaw angle after arriving at target position
            x (float): Target Position X coordinate in the locator coordinate system.  The positive X axis is to the right on boot or locator reset (along yaw angle -90 degrees)
            y (float): Target Position Y coordinate in the locator coordinate system.  The positive Y axis is forward on boot or locator reset
            linear_speed (int8_t): Maximum normalized linear speed in transit to the target position, normalized to [0..127].  If the distance to target is too short for the robot to accelerate to this velocity, the resulting velocity trajectory will be triangular rather than trapezoidal.
            flags (uint8_t): Option flags
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_to_position_normalized(yaw_angle, x, y, linear_speed, flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_xy_position_drive_result_notify(self, handler=None, timeout=None): 
        """Reached target (x,y) position async, sent by the robot on completion of an (x,y) position drive command, indicating success or failure

        Args:
            handler (function): called asynchronously, takes form handler(success).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = drive.on_xy_position_drive_result_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def set_drive_target_slew_parameters(self, a, b, c, linear_acceleration, linear_velocity_slew_method, timeout=None): 
        """Set Drive Target Slew Parameters, 
Configures a quadratic relationship between the yaw target slew limit in degrees/s and the current linear velocity.
The parameters a,b,c are quadratic coefficients.
let y be the yaw target slew limit in deg/s, and let x be the current linear velocity.
y = ax^2 + bx + c
linearAcceleration is in m/s.  LinearVelocitySlewMethod determines the meaning of linearAcceleration

        Args:
            a (float): `a` coefficient of the quadratic equation
            b (float): `b` coefficient of the quadratic equation
            c (float): `c` coefficient of the quadratic equation
            linear_acceleration (float): Linear acceleration
            linear_velocity_slew_method (uint8_t): Linear velocity slew method
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.set_drive_target_slew_parameters(a, b, c, linear_acceleration, linear_velocity_slew_method, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_drive_target_slew_parameters(self, timeout=None): 
        """Get Drive Target Slew Parameters. 
Retrieves the parameters for the quadratic relationship between the yaw target slew limit in degrees/s and the current linear velocity.
The parameters a,b,c are quadratic coefficients.
let y be the yaw target slew limit in deg/s, and let x be the current linear velocity.
y = ax^2 + bx + c
linearAcceleration is in m/s.  LinearVelocitySlewMethod determines the meaning of linearAcceleration

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: a (float), b (float), c (float), linear_acceleration (float), linear_velocity_slew_method (uint8_t)
        """
        command_dict = drive.get_drive_target_slew_parameters(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_stop_custom_decel(self, deceleration_rate, timeout=None): 
        """Stops the robot with a custom deceleration rate, which is applied to the motor that is spinning faster when the command was received.  The opposite motor is ramped down at a rate that maintains the initial velocity ratio of the 2 motors.  This will maintain straight/turning behavior during braking

        Args:
            deceleration_rate (float): deceleration rate in m/s^2
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_stop_custom_decel(deceleration_rate, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_robot_has_stopped_notify(self, handler=None, timeout=None): 
        """Robot has stopped notification

        Args:
            handler (function): called asynchronously, takes form handler().
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = drive.on_robot_has_stopped_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def restore_default_drive_target_slew_parameters(self, timeout=None): 
        """Restores drive target slew parameters to defaults

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.restore_default_drive_target_slew_parameters(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_stop_controller_state(self, timeout=None): 
        """Get Stop Controller State.  Use this to poll whether the robot has stopped, while using the stop controller

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: stopped (bool)
        """
        command_dict = drive.get_stop_controller_state(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_stop(self, timeout=None): 
        """Brings the drive motors to a stop using the default deceleration rate, which is applied to the motor that was spinning faster when the command was received.  The opposite motor is ramped down at a rate that maintains the initial velocity ratio of the 2 motors.  This will maintain straight/turning behavior during braking

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.drive_stop(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def restore_default_control_system_timeout(self, timeout=None): 
        """Restores the default control system timeout

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.restore_default_control_system_timeout(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_active_control_system_id(self, timeout=None): 
        """Get the ID of the active controller

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: controller_id (uint8_t)
        """
        command_dict = drive.get_active_control_system_id(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def restore_initial_default_control_systems(self, timeout=None): 
        """Restore initial default control systems.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = drive.restore_initial_default_control_systems(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_default_control_system_for_type(self, control_system_type, timeout=None): 
        """Get the ID of the default control system for the given type

        Args:
            control_system_type (uint8_t): Control system type
            timeout (float): maximum time to await a response.

        Returns:
            dict: controller_id (uint8_t)
        """
        command_dict = drive.get_default_control_system_for_type(control_system_type, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_gyro_max_notify(self, is_enabled, timeout=None): 
        """Enables the Async messages for when the Gyro max is hit.

        Args:
            is_enabled (bool): Boolean set for if you would like a notification when the Gyro max is hit. True for enabled. False for disabled.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_gyro_max_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_gyro_max_notify(self, handler=None, timeout=None): 
        """Occurs when the robot spins faster than the sensor can see in any axis.

        Args:
            handler (function): called asynchronously, takes form handler(flags).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_gyro_max_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def reset_locator_x_and_y(self, timeout=None): 
        """Resets the locator module's current X and Y values to 0.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.reset_locator_x_and_y(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_locator_flags(self, flags, timeout=None): 
        """Sets flags for the locator module.

        Args:
            flags (uint8_t): Auto calibrate: When set, the robot will maintain the same X - Y axis from initial startup. When cleared, the robot will reset the X - Y axis orientation when a driving yaw reset command is sent.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.set_locator_flags(flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bot_to_bot_infrared_readings(self, timeout=None): 
        """An 8-bit value is returned for each infrared sensor, assigned by mask.
Mask description on BOLT: 32'h0000_00ff: front left sensor 32'h0000_ff00: front right sensor 32'h00ff_0000: back right sensor 32'hff00_0000: back left sensor

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: sensor_data (uint32_t)
        """
        command_dict = sensor.get_bot_to_bot_infrared_readings(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_rgbc_sensor_values(self, timeout=None): 
        """Return raw data being read by RGBC sensor on each sensor channel

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: red_channel_value (uint16_t), green_channel_value (uint16_t), blue_channel_value (uint16_t), clear_channel_value (uint16_t)
        """
        command_dict = sensor.get_rgbc_sensor_values(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def magnetometer_calibrate_to_north(self, timeout=None): 
        """Start magnetometer calibration to find north.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.magnetometer_calibrate_to_north(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_broadcasting(self, far_code, near_code, timeout=None): 
        """For robot following, broadcasting robots emit two codes: one for long distance (3 meters +), and one for short distance (< 1 meter). Following robots use both of these codes to determine direction and distance from the broadcasting robot.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_broadcasting(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_following(self, far_code, near_code, timeout=None): 
        """Registers a far code and near code for a following robot to follow. Following robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_following(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_broadcasting(self, timeout=None): 
        """Halts current broadcasting or following. De-registers far code and near code on broadcasting or following robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_broadcasting(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_robot_to_robot_infrared_message_received_notify(self, handler=None, timeout=None): 
        """Async sent when a registered robot to robot infrared message is received. In response returns the infrared code listened for.

        Args:
            handler (function): called asynchronously, takes form handler(infrared_code).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_robot_to_robot_infrared_message_received_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_ambient_light_sensor_value(self, timeout=None): 
        """Ambient light value is returned; higher = more light!

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: ambient_light_value (float)
        """
        command_dict = sensor.get_ambient_light_sensor_value(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_following(self, timeout=None): 
        """Halts current following. De-registers far code and near code on following robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_following(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_evading(self, far_code, near_code, timeout=None): 
        """Registers a far code and near code for a evading robot to evade. Evading robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.

        Args:
            far_code (uint8_t): Code between 0 and 7 that the robot emits for long distance (3+ meters) communication so that bots receiving it will know that it is further away.
            near_code (uint8_t): Code between 0 and 7 that the robot emits for short distance (<1 meters) communication so that bots receiving it will know that it is closer.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_robot_to_robot_infrared_evading(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_evading(self, timeout=None): 
        """Halts current evading. De-registers far code and near code on evading robot.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_robot_to_robot_infrared_evading(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_color_detection_notify(self, is_enabled, interval, minimum_confidence_threshold, timeout=None): 
        """Enable or disable asynchronous color detection notifications. The user must provide an interval and a confidence threshold

        Args:
            is_enabled (bool): True for enable.  False for disable
            interval (uint16_t): Interval, in milliseconds, that color detection asyncs will be sent.
            minimum_confidence_threshold (uint8_t): The minimum confidence level, from 0 to 255, that must be met before an async is sent.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_color_detection_notify(is_enabled, interval, minimum_confidence_threshold, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_color_detection_notify(self, handler=None, timeout=None): 
        """Notification sent on the interval set by the user in enable_color_detection_notification with information about the color detected.  The color classification ID 0xFF is a special value indicating that the color could not be identified (e.g., because the reading was too dark).  This is expected behavior when the ring is tapped in the air with the sensor facing out.

        Args:
            handler (function): called asynchronously, takes form handler(red, green, blue, confidence, color_classification_id).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_color_detection_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_current_detected_color_reading(self, timeout=None): 
        """Note: this does not return anything.  Instead, a color_detection_notify async will be sent after measurement with the answer.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.get_current_detected_color_reading(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_color_detection(self, is_enabled, timeout=None): 
        """Enables the color detection module.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_color_detection(is_enabled, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def configure_streaming_service(self, token, configuration, target, timeout=None): 
        """Configure streaming services.

        Args:
            token (uint8_t): None
            configuration (list(uint8_t)): Array containing the configuration of the client, like the service ID and size.
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.configure_streaming_service(token, configuration, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_streaming_service(self, period, target, timeout=None): 
        """Start all streaming services for a client

        Args:
            period (uint16_t): Interval between sensor streaming packets in milliseconds.
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.start_streaming_service(period, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_streaming_service(self, target, timeout=None): 
        """Stops all streaming services for a client

        Args:
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.stop_streaming_service(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def clear_streaming_service(self, target, timeout=None): 
        """Clears all streaming services for a client

        Args:
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.clear_streaming_service(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_streaming_service_data_notify(self, target, handler=None, timeout=None): 
        """Streaming data notification for a client configuration

        Args:
            handler (function): called asynchronously, takes form handler(token, sensor_data).
            target (uint8_t): 1 or 2.
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_streaming_service_data_notify(target=target, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def enable_robot_infrared_message_notify(self, is_enabled, timeout=None): 
        """Starts listening for infrared messages sent to the robot and will send an async message when received.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_robot_infrared_message_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def send_infrared_message(self, infrared_code, front_strength, left_strength, right_strength, rear_strength, timeout=None): 
        """Send specified code to any robot in the vicinity. The on/off for each sensor is controlled individually but there can only be one range for all sensors. Therefore, the acceptable combination of emitters strength would be: 5, 5, 0, 0 or 5, 5, 5, 5 or 0, 0, 0, 5, etc.

        Args:
            infrared_code (uint8_t): The only valid messages to send this way have an ID between 0 and 7.
            front_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            left_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            right_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            rear_strength (uint8_t): The range goes from 0-64, where 0 is no message sent, and 64 is the longest achievable range.
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.send_infrared_message(infrared_code, front_strength, left_strength, right_strength, rear_strength, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_temperature(self, id0, id1, timeout=None): 
        """Get temperature reading from a set of sensors. 'Sensors' may be physical, or simulated.

        Args:
            id0 (uint8_t): ID of first requested temperature sensor
            id1 (uint8_t): ID of second requested temperature sensor
            timeout (float): maximum time to await a response.

        Returns:
            dict: id0 (uint8_t), temp0 (float), id1 (uint8_t), temp1 (float)
        """
        command_dict = sensor.get_temperature(id0, id1, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_motor_thermal_protection_status(self, timeout=None): 
        """Get motor thermal protection status.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: left_motor_temperature (float), left_motor_status (uint8_t), right_motor_temperature (float), right_motor_status (uint8_t)
        """
        command_dict = sensor.get_motor_thermal_protection_status(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_motor_thermal_protection_status_notify(self, is_enabled, timeout=None): 
        """Enable motor thermal protection status notifications.

        Args:
            is_enabled (bool): True for enable.  False for disable
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.enable_motor_thermal_protection_status_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_motor_thermal_protection_status_notify(self, handler=None, timeout=None): 
        """Motor thermal protection status notification.

        Args:
            handler (function): called asynchronously, takes form handler(left_motor_temperature, left_motor_status, right_motor_temperature, right_motor_status).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_motor_thermal_protection_status_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def on_magnetometer_calibration_complete_notify(self, handler=None, timeout=None): 
        """Magnetometer calibration complete notify.

        Args:
            handler (function): called asynchronously, takes form handler(is_successful, yaw_north_direction).
            timeout (float): maximum time to await a response.
        Returns:
            Task (Future) from which `handler` will be called
        """
        command_dict = sensor.on_magnetometer_calibration_complete_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_magnetometer_reading(self, timeout=None): 
        """Get current magnetometer reading.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: x_axis (float), y_axis (float), z_axis (float)
        """
        command_dict = sensor.get_magnetometer_reading(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_encoder_counts(self, timeout=None): 
        """Get array of all encoder counts. Returned as left wheel and then right wheel encoder counts.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: encoder_counts (list(int32_t))
        """
        command_dict = sensor.get_encoder_counts(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def disable_notifications_and_active_commands(self, timeout=None): 
        """Disable notifications and active commands.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = sensor.disable_notifications_and_active_commands(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bluetooth_advertising_name(self, timeout=None): 
        """Returns null-terminated string with the BLE advertising name (e.g., "BL-ABCD").

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: name (str)
        """
        command_dict = connection.get_bluetooth_advertising_name(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_all_leds(self, led_group, led_brightness_values, timeout=None): 
        """LED affected mask can affect up to 32 LEDs simultaneously. 0 = not affected. 1 = affected (update this LED). If mask value is set to 1, you must provide a value in the LED data array.

        Args:
            led_group (uint32_t): Bitmask selecting which LEDs to change (32-bit).
            led_brightness_values (list(uint8_t)): Array of RGB values for each of the selected LEDs (1 to 32 bytes; length depends on robot).
            timeout (float): maximum time to await a response.
        """
        command_dict = io.set_all_leds(led_group, led_brightness_values, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_active_color_palette(self, timeout=None): 
        """The response data will list all assigned color palette slots in the system.

        Args:
            timeout (float): maximum time to await a response.

        Returns:
            dict: rgb_index_bytes (list(uint8_t))
        """
        command_dict = io.get_active_color_palette(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_active_color_palette(self, rgb_index_bytes, timeout=None): 
        """Each entry in the array corresponds to one color slot in the system.  Any unmentioned slot indices will be marked unassigned.

        Args:
            rgb_index_bytes (list(uint8_t)): struct array -- index, red, green, blue -- that stores the contents of the color palette to be set as the active color palette.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.set_active_color_palette(rgb_index_bytes, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_color_identification_report(self, red, green, blue, confidence_threshold, timeout=None): 
        """The response to this command will provide an array of color palette entries that would match on the provided color with higher confidence than the given threshold.

        Args:
            red (uint8_t): Red ('R') value of the color to be matched.
            green (uint8_t): Green ('G') value of the color to be matched.
            blue (uint8_t): Blue ('B') value of the color to be matched.
            confidence_threshold (uint8_t): How closely the palette should match the provided color. The confidence threshold is in [0, 255].
            timeout (float): maximum time to await a response.

        Returns:
            dict: index_confidence_byte (list(uint8_t))
        """
        command_dict = io.get_color_identification_report(red, green, blue, confidence_threshold, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def load_color_palette(self, palette_index, timeout=None): 
        """Loads the specified color palette into the active palette.

        Args:
            palette_index (uint8_t): The index of (number that identifies) the color palette to be loaded.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.load_color_palette(palette_index, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def save_color_palette(self, palette_index, timeout=None): 
        """Stores the active palette into the palette at palette index (see table above).

        Args:
            palette_index (uint8_t): The index of (number that identifies) the color palette to be stored.
            timeout (float): maximum time to await a response.
        """
        command_dict = io.save_color_palette(palette_index, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def release_led_requests(self, timeout=None): 
        """Releases LED requests to show the idle indication.

        Args:
            timeout (float): maximum time to await a response.
        """
        command_dict = io.release_led_requests(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)
